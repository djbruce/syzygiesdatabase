---
layout: default
title: SyzygyData
description: SyzygyData, a project about computing syzygies.
---
<div class="container-fluid">

	<p>A central open question in the study of syzygies is to describe the Betti
		table of \(\mathbb{P}^{n}\) under the degree \(d\) Veronese embedding. While
		the case when \(n=1\) is fully understood and classical &mdash; the minimal resolution is 
		given by an Eagon-Northcott complex &mdash; in higher dimensions this problem is almost entirely
		open. For example, when \(n=2\), not only is a complete description unknown, but only a handful
		of examples have ever been computed.
		
		<p class="lead">The goal of this project is to use numerical linear algebra and high speed
		massively distributed computing to systematically gather new examples of Betti
		tables of Veronese embeddings of \(\mathbb{P}^n\).
		</p>

		In general such computations are quite difficult even for relatively small \(n\) and small \(d\).
		For instance, when \(n=2\) and \(d\leq 3\), one can compute the entire Betti table
		with paper and pencil or instantly via Macaulay2. Likewise, when \(d=4\), Macaulay2 is able to perform the computation
		in roughly 30 seconds.
		However, when \(d=5\), Macaulay2 fails to terminate, and this was only recently computed via alternative methods.
		One cause of difficult with such computations is that the number of variables grows on the order of \(O(d^{n})\). 
		This means the computational complexity ratchets up quite dramatically.
		</br>
		</br>
		In order to achieve our goal we approach the task of computing Betti numbers in a somewhat
		novel fashion. First instead of using symbolic Gr&ouml;bner methods we rely upon
		linear algebra seeking to explicitly compute the cohomology
		of the Koszul complex. Along the way we rephrase the question slightly, seeking to compute multigraded Betti numbers.
		This breaks massive (largely infeasible) computations into a huge number of (slightly) more tractable one. 
		This approach in itself is not new. The community has long known that one could use linear algebra to compute syzygies. However, to our knowledge
		until recently no one has made use of this approach, likely because the resulting computations are still quite daunting, both individually and in sum. 
		(See the <a href="{{site.baseurl}}/background">Background</a> page for a more complete description.)
		</br>
		</br>
		Second we create a framework to systematically perform such computations making use of high 
		speed distributed computing and highly efficient sparse matrix algorithms. In large part the 
		novelty of this project lies in this execution. This framework makes use of the fact that
		the necessary computations can be done independently of one another. So using HTCondor we are
		able to distribute our computations across a wide pool of computers. (See the <a href="{{site.baseurl}}/approach">Approach</a> page for a more in-depth description of our methodology.)
		</br>
		</br>
		While others [1] have recently implemented similar ideas regarding the computation of graded Betti numbers, our approach has a few additional benefits,
		one being that in addition to computing the graded Betti numbers we also compute the corresponding Schur functor decomposition. 
		As \(d\) increases the graded and multigraded Betti numbers of the Veronese embedding grow quickly, 
		becoming so large and numerous as to be difficult to work with. 
		In particular, the size of the individual Betti numbers &mdash; in the hundreds of millions &mdash; obscures much of the underlying structure and any patterns. However, packaging this data via the associated Schur functors 
		makes the data easier to work with.
		</br>
		</br>
		Our belief in generating this experimental data is that it will lead to new conjectures, and verify existing ones, about the syzygies of Veroneses. (See the <a href="{{site.baseurl}}/conjectures">Conjectures</a> page for a list of conjectures and questions we have raised.) 
		Thus we are content working with numerical algorithms, despite the potential for accidentally rounding a minuscule value down to zero. 
		(Note: Our Schur functors methods allow us to catch and correct most small rounding errors. See Our Approach for further description.)
		</p>	
		
	
</div>
