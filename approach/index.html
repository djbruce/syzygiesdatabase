---
layout: default
title: Approach
description: SyzygyData, a project about computing syzygies.
---
<div class="container-fluid">

	<p>
We compute the syzygies of \(\mathbb{P}^n\) via numerical linear algebra and high throughput/performance computing.  (While our actual computations are focused on the case of \(\mathbb{P}^2\), we describe the approach for general \(n\).) 
 Continuing the notation from <a href="">Background</a> page \(K_{p,q}(n,b;d)\) is the cohomology of the complex:
\[\bigwedge^{p+1}S_{d}\otimes S_{b+(q-1)d}\xrightarrow{\quad \partial_{p+1} \quad}\bigwedge^{p}S_{d}\otimes S_{b+qd}\xrightarrow{\quad \partial_{p} \quad}\bigwedge^{p-1}S_{d}\otimes S_{b+(q+1)d},\]
where the differentials are given by
\[\partial_{p}(m_1\wedge m_2\wedge \cdots \wedge m_p\otimes f)=\sum_{k=1}^p(-1)^km_1\wedge m_2\wedge \cdots \wedge \hat{m}_{k}\wedge \cdots \wedge m_p\otimes(m_kf).\]
Since these differentials respect the \(\mathbb{Z}^{n+1}\)-grading on \(S\), the above complex may be decomposed into its
multigraded strands.  Thus for any multidegree \(\textbf{a}\), we may compute \(K_{p,q}(n,b;d)_{\textbf{a}}\) via the cohomology of:
\[\left(\bigwedge^{p+1}S_{d}\otimes S_{b+(q-1)d}\right)_{\textbf{a}}\xrightarrow{\quad \partial_{p+1,\textbf{a}} \quad}\left(\bigwedge^{p}S_{d}\otimes S_{b+qd}\right)_{\textbf{a}}\xrightarrow{\quad \partial_{p,\textbf{a}} \quad}\left(\bigwedge^{p-1}S_{d}\otimes S_{b+(q+1)d}\right)_{\textbf{a}}.\]
It thus suffices to compute the ranks of the linear transformations \(\partial_{p+1,\textbf{a}}\) and \(\partial_{p+1,\textbf{a}}\). With this in mind our computation can roughly be broken down into three steps.  These are described in detail in Sections 3, 4, and 5 of our paper  
<a href="http://arxiv.org/abs/1711.03513">arXiv:1711.03513</a>.
</p>
<div class="panel-group" id="accordion">
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title"><a data-toggle="collapse" data-parent="#accordion" href="#collapse1">Pre-Computation</a></h4>
    </div>
    <div id="collapse1" class="panel-collapse collapse">
      <div class="panel-body">
      <p>
We use known vanishing results and facts about Hilbert series to reduce the number of matrices whose 
rank we need to compute. We also use standard duality results to focus on simpler matrices in some cases.  
</p>
      </div>
    </div>
  </div>
 
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title"><a data-toggle="collapse" data-parent="#accordion" href="#collapse2">Main Computation</a></h4>
    </div>
    <div id="collapse2" class="panel-collapse collapse">
      <div class="panel-body">
      <p>
      We construct matrices representing the relevant differentials  \(\partial_{p+1,\textbf{a}}\).  We then use an LU-decomposition algorithm and distributed, high throughput computations to compute the ranks of those matrices.
</p>
      </div>
    </div>
  </div>
 
  <div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title"><a data-toggle="collapse" data-parent="#accordion" href="#collapse3">Post-Processing</a></h4>
    </div>
    <div id="collapse3" class="panel-collapse collapse">
      <div class="panel-body">
      <p>
      We assemble our data to produce the total the multigraded Betti numbers and the standard Betti numbers, 
      and we apply a highest weight decomposition algorithm to obtain the Schur module decompositions.
</p>
      </div>
    </div>
  </div>
</div>
<p>
</p>
</div>